;; This file contains helper functions that are specific to a tree data structure.
!(import! &self list-helpers)

;; Function to build a tree of type "Tree" from an expression
(: buildTree (-> Expression Tree))
(= (buildTree $expr) 
  (case $expr
    (
      ( (AND $a $b) (TreeNode (Value Nil False AND) Nil (Cons (buildTree $a) (Cons (buildTree $b) Nil))) )
      ( (OR $a $b) (TreeNode (Value Nil False OR) Nil (Cons (buildTree $a) (Cons (buildTree $b) Nil))))
      ( (NOT $x) (TreeNode (Value Nil False NOT) Nil (Cons NilNode (Cons (buildTree $x) Nil))))
      ( $symbol (TreeNode (Value $symbol False LITERAL) Nil Nil))
    )
  )
)

;; Function to build a tree using the "buildTree" function but always appends a root node of type "ROOT".
(: buildTreeWithRoot (-> Expression Tree))
(= (buildTreeWithRoot $expr)
  (TreeNode (Value Nil False ROOT) Nil (Cons NilNode (Cons (buildTree $expr) Nil)))
)

;; A function to get the right or left child of a tree.
;; The function assumes that the tree's first child is the left one and
;; the second one is the right child. It ignores the rest of the children if present.
(: getChild (-> Tree Location Tree))
(= (getChild (TreeNode $nodeValue $guardSet Nil) $opt) NilNode)
(= (getChild (TreeNode $nodeValue $guardSet (Cons $l $xs)) L) $l)
(= (getChild (TreeNode $nodeValue $guardSet (Cons $l Nil)) R) NilNode)
(= (getChild (TreeNode $nodeValue $guardSet (Cons $l (Cons $r $xs))) R) $r)

;; A function to get node children.
(: getChildren (-> Tree (List Tree)))
(= (getChildren (TreeNode $nodeVal $guardSet $children)) $children)

;;A function to get child node of a tree at a given index
(:getChildAt (-> Tree Number Tree))
(= (getChildAt (TreeNode $nodeValue $guardSet Nil) $i) NilNode)
(= (getChildAt (TreeNode $nodeValue $guardSet (Cons $x $xs)) $i)
    (if (== Nil (index $i (Cons $x $xs)))
        NilNode
        (index $i (Cons $x $xs))
    )
)
;; A function to get guardset.
(: getGuardSet (-> Tree (List Tree)))
(= (getGuardSet (TreeNode $nodeValue $guardSet $children)) $guardSet)

; Given a tree and the new type, it returns a new tree with the new type.
(: changeType (-> Tree NodeType Tree))
(= (changeType (TreeNode (Value $nodeValue $boolean $_) $guardSet $children) $newType)
  (TreeNode (Value $nodeValue $boolean $newType) $guardSet $children)
)

;; Given a binary tree node and position (left, right) indicating which child to update, replace it's left or right child with the given node.
;; (node location (L or R) newNode)
(: replaceChild (-> Tree Tree Location Tree))
(= (replaceChild (TreeNode $nodeValue $guardSet Nil) $newNode L) 
  (TreeNode $nodeValue $guardSet (Cons $newNode Nil))
)
(= (replaceChild (TreeNode $nodeValue $guardSet (Cons $l $xs)) $newNode L)
  (TreeNode $nodeValue $guardSet (Cons $newNode $xs))
)
(= (replaceChild (TreeNode $nodeValue $guardSet Nil) $newNode R) 
   (TreeNode $nodeValue $guardSet (Cons $newNode Nil))
)
(= (replaceChild (TreeNode $nodeValue $guardSet (Cons $l Nil)) $newNode R)
  (TreeNode $nodeValue $guardSet (Cons $l (Cons $newNode Nil)))
)
(= (replaceChild (TreeNode $nodeValue $guardSet (Cons $l (Cons $r $xs))) $newNode R)
  (TreeNode $nodeValue $guardSet (Cons $l (Cons $newNode $xs)))
)

;; replace child of a node goven an index.
(:replaceChildAt (-> Tree Tree Number Tree))
(= (replaceChildAt (TreeNode $nodeValue $guardSet $children) $newNode $i)
    (TreeNode $nodeValue $guardSet (replaceAtIndex $i $newNode $children))
)

;; Given a node and a tree, prepend the tree to the node's children.
(: prependChild (-> Tree Tree Tree))
(= (prependChild (TreeNode $nodeValue $guardSet $children) $child)
  (TreeNode $nodeValue $guardSet (Cons $child $children))
)


;; Given a tree and new guard set, it will return a new tree with the updated guard set.
(: replaceGuardSet (-> Tree (List Tree) Tree) )
(= (replaceGuardSet NilNode $newguardSet) NilNode)
(= (replaceGuardSet (TreeNode $value $guardSet $children) $newguardSet) (TreeNode $value $newguardSet $children))

;; Given a tree and new children, it will return a new tree with the updated children.
(: replaceChildren (-> Tree (List Tree) Tree))
(= (replaceChildren NilNode $newChildren) NilNode)
(= (replaceChildren (TreeNode $value $guardSet $children) $newChildren) (TreeNode $value $guardSet $newChildren))

;; Given a tree and the new node value, it will return a new tree with the updated node value.
(: replaceNodeValue (-> Tree NodeValue Tree))
(= (replaceNodeValue $tree $newValue)
    (let ($value $left $right $guardSet $children) 
        $node
        (TreeNode $newValue $left $right $new-guardSet $children)
    )
)

;; Given two tree nodes, it compares and returns boolean value by comparing only their value.
;; A tree's value is the node value, constraint and the type of the node.
(:isNodeEqual (-> Tree Tree Bool))
(= (isNodeEqual NilNode NilNode) False)
(= (isNodeEqual (TreeNode $nodeValue $guardSet $children) NilNode) False)
(= (isNodeEqual NilNode (TreeNode $nodeValue $guardSet $children)) False)
(= (isNodeEqual 
    (TreeNode $nodeValue1 $guardSet1 $children1) 
    (TreeNode $nodeValue2 $guardSet2 $children2)
   )
  (== $nodeValue1 $nodeValue2)
)

;; Function to check if a tree is member of a treelist.
(: treeIsMember (-> Tree (List Tree) Bool))
(= (treeIsMember $x $list)
   (memberWith isNodeEqual $x $list)
)

;;function to return the intersection of two treelists by comparing only their node value.
(: treeIntersection (-> (List Tree) (List Tree) (List Tree)))
(= (treeIntersection $list1 $list2)
  (setIntersection treeIsMember $list1 $list2 Nil)
)

;; A function that computes intersection of lists of trees.
;; This is taken from the Python implementation with the same name.
(: intersections (-> (List Tree) (List Tree) (List Tree)))
(= (intersections $intersectionSet $children)
  (
    if(== (length $children) 0) Nil 
      (
        let* 
        (
          ($guardSet (getGuardSet (head $children)))
          ($intersections (treeIntersection $intersectionSet $guardSet))
          ($finalResult (intersections $intersections (tail $children)))
        )
        $finalResult
      )
  )
)

;; Function that gets the node type.
(: getNodeType (-> Tree Atom))
(= (getNodeType (TreeNode (Value $value $bool $nodeType) $guardSet $children)) $nodeType)

;; Function that gets the node value.
(: getNodeValue (-> Tree Atom))
(= (getNodeValue (TreeNode (Value $value $truthValue $nodeType) $guardSet $children)) $value)

;; Function to find a given node from a list of nodes and remove it. 
;; Similar to findAndRemove implementation of for the lists except it only works for trees.
(: findAndRemoveTree (-> Tree (List Tree) (List Tree)))
(= (findAndRemoveTree $elem Nil) Nil)
(= (findAndRemoveTree $elem (Cons $x $xs))
    (if (isNodeEqual $x $elem)
        (findAndRemoveTree $elem $xs)
        (Cons $x (findAndRemoveTree $elem $xs))
    )
)

; Update GrandChild guardset with the difference between the current guardset and the given list of trees.
(: computeGrandchildGuardset (-> Tree (List Tree) Tree))
(= (computeGrandchildGuardset NilNode $resultSet) NilNode)
(= (computeGrandchildGuardset (TreeNode $nodeValue $guardSet $children) $resultSet)
  (TreeNode $nodeValue (setDifference treeIsMember $guardSet $resultSet Nil) $children)
)

;; A function that detect consistency (value match and constraint difference) between a single tree and list of tree.
(: detectConsistency (-> Tree (List Tree) Bool))
(= (detectConsistency $tree Nil) True)
(= (detectConsistency 
    (TreeNode (Value $fstValue $fstConstraint $fstNodetype) $fstGuardSet $fstChildren)
    (Cons (TreeNode (Value $sndValue $sndConstraint $sndNodetype) $sndGuardSet $sndChildren) $restOfTree)
   )
   (if 
     (and 
       (== $fstValue $sndValue) 
       (not (== $fstConstraint $sndConstraint))
     )
       False
       (detectConsistency 
         (TreeNode (Value $fstValue $fstConstraint $fstNodetype) $fstGuardSet $fstChildren) 
         $restOfTree
       )
   )
)

;; A function check the consistency of a tree list.
(: isConsistent (-> (List Tree) Bool))
(= (isConsistent Nil) True)
(= (isConsistent (Cons $x $xs))
  (if (detectConsistency $x $xs)
    (isConsistent $xs)
    False
  )
)

(: allExceptTargetType (-> (List Tree) NodeType (List Tree)))
(= (allExceptTargetType Nil $nodeType) Nil)
(= (allExceptTargetType $treeList $nodeType) 
  (let  
    (Cons $tree $rest) 
    $treeList 
    (unify 
      $tree  
      (TreeNode (Value $value $truthValue $nodeType) $guardSet $children)
      (allExceptTargetType $rest $nodeType)
      (Cons $tree (allExceptTargetType $rest $nodeType))
    )
  )
)



; below are helper functions for DELETE AND and OR subtree handlers
(: delete_AND_SubTree (-> Tree Tree) )
(= (delete_AND_SubTree Nil) Nil )
(= (delete_AND_SubTree $tree) 
  (let 
    (TreeNode $nodeValue $guardSet $children) $tree
    (TreeNode $nodeValue $guardSet (allExceptTargetType $children AND))
  )
)

(: delete_OR_SubTree (-> Tree Tree) )
(= (delete_OR_SubTree Nil) Nil )
(= (delete_OR_SubTree $tree) 
  (let 
    (TreeNode $nodeValue $guardSet $children) $tree
    (TreeNode $nodeValue $guardSet (allExceptTargetType $children OR))
  )
)

(: prependToGuardSet (-> Tree Tree Tree))
(= (prependToGuardSet (TreeNode $nodeValue $guardSet $children) $node)
  (TreeNode $nodeValue (Cons $node $guardSet) $children)
)

;; Returns a boolean value after it compares two trees.
;; This implementation doesn't assume a set is ordered and checks if
;; both sets are identical.
(: compareSets (-> (List Tree) (List Tree) Bool))
(=(compareSets $firstSet $secondSet)
  (let*
    (
      ($firstDifference (setDifference treeIsMember $firstSet $secondSet Nil))
      ($secondDifference (setDifference treeIsMember $secondSet $firstSet Nil))
    )
    (if (and (== $firstDifference Nil) (== $secondDifference Nil))
      True
      False
    )
  )
)
;; Retrieves for the head of Children in a List of tree given a tree
(: headOfChildren (-> (List Tree) Tree))
(= (headOfChildren Nil) NilNode)
(= (headOfChildren (Cons $x $xs))
  $x
)
;; Retrieves for the tail of Children in a tree it provides a list of tree.
(: tailOfChildren (-> Tree (List Tree)))
(= (tailOfChildren NilNode) Nil)
(= (tailOfChildren (TreeNode $nodeValue $guardSet $children))
    (let (Cons $x $xs) $children $xs)
)

;; A tree left fold funcction that works like tree fold in haskell.
(= (treeFoldl $func $acc NilNode) $acc)
(= (treeFoldl $func $acc (TreeNode $nodeVal $leftTree $rightTree $guardSet $children))
  (case $nodeVal
    (
      ( (Value $val $truthVal LITERAL) 
        ($func $acc $val)
      )
      ( (Value $val $truthVal ROOT)
        (treeFoldl $func $acc $rightTree)
      )
      ( (Value $val $truthVal NOT)
        (treeFoldl $func $acc $rightTree)
      )
      ( (Value $val $truthVal AND)
        (treeFoldl $func (treeFoldl $func $acc $leftTree) $rightTree)
      )
      ( (Value $val $truthVal OR)
        (treeFoldl $func (treeFoldl $func $acc $leftTree) $rightTree)
      )
    )
  )
)

;; A tree right fold funcction that works like tree fold in haskell.
(= (treeFoldr $func $acc NilNode) $acc)
(= (treeFoldr $func $acc (TreeNode $nodeVal $leftTree $rightTree $guardSet $children))
  (case $nodeVal
    (
      ( (Value $val $truthVal LITERAL) ($func $acc $val) )
      ( (Value $val $truthVal ROOT) (treeFoldl $func $acc $rightTree) )
      ( (Value $val $truthVal NOT) (treeFoldl $func $acc $rightTree) )
      ( (Value $val $truthVal AND)
        (treeFoldl $func (treeFoldl $func $acc $leftTree) $rightTree)
      )
      ( (Value $val $truthVal OR)
        (treeFoldl $func (treeFoldl $func $acc $leftTree) $rightTree)
      )
    )
  )
)
